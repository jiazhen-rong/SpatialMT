% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HMRF.R
\name{ICM_update}
\alias{ICM_update}
\title{Iterated Conditional Modes (ICM) Update for HMRF}
\usage{
ICM_update(
  X_j,
  N_j,
  Z_j,
  pi_j0,
  gamma,
  pi_1j,
  neighbor_s_vaf,
  Wc,
  neighbor_s_list,
  neighbor_num = 4,
  icm_iter = 10,
  prior_energy = F,
  verbose = F
)
}
\arguments{
\item{X_j}{Numeric vector of observed variant allele counts for each spatial location.}

\item{N_j}{Numeric vector of total read counts for each spatial location.}

\item{Z_j}{Numeric vector of current latent variable assignments (0 = background, 1 = carrier).}

\item{pi_j0}{Background probability parameter, controlling the baseline variant allele frequency.}

\item{gamma}{Scaling parameter for the neighborhood variant allele frequency effect.}

\item{pi_1j}{Carrier probability parameter, affecting locations labeled as carriers.}

\item{neighbor_s_vaf}{Numeric vector of neighborhood variant allele frequencies.}

\item{Wc}{Numeric vector of weighted cell-type proportions at each location.}

\item{neighbor_s_list}{List where each element contains the indices of neighboring spots.}

\item{neighbor_num}{Integer specifying the number of neighbors to consider for each spot.}

\item{icm_iter}{Maximum number of ICM iterations to perform.}

\item{prior_energy}{Logical; if \code{TRUE}, incorporates a prior energy function in the update.}

\item{verbose}{Logical; if \code{TRUE}, prints debug information during iterations.}
}
\value{
Updated numeric vector \eqn{Z_j} containing the refined latent variable assignments.
}
\description{
This function updates the latent variable \eqn{Z_j} using the Iterated Conditional Modes (ICM) algorithm.
It iteratively optimizes \eqn{Z_j} to maximize the posterior probability, considering both
the likelihood of the observed data and the influence of spatial neighbors.
}
\details{
The ICM algorithm updates each \eqn{Z_j} sequentially by maximizing its posterior probability:
\deqn{P(Z_j | X_j, \text{neighbors}) \propto P(X_j | Z_j) P(Z_j | \text{neighbors})}
It iterates until convergence or until the specified maximum number of iterations is reached.
If \code{prior_energy = TRUE}, the function incorporates a spatial prior that penalizes
differences between neighboring \eqn{Z_j} values.
}
\examples{
# Example usage:
X_j <- c(10, 5, 8)
N_j <- c(100, 50, 80)
Z_j <- c(0, 1, 0)
neighbor_s_list <- list(c(2,3), c(1,3), c(1,2))
neighbor_s_vaf <- c(0.1, 0.05, 0.08)
Wc <- c(0.2, 0.1, 0.3)

updated_Z_j <- ICM_update(X_j, N_j, Z_j, pi_j0 = 0.1, gamma = 0.5, pi_1j = 0.5, 
                           neighbor_s_vaf, Wc, neighbor_s_list, neighbor_num = 4, 
                           icm_iter = 10, prior_energy = FALSE, verbose = TRUE)
print(updated_Z_j)
}
